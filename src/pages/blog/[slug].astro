---
import BaseLayout from "../../layouts/BaseLayout.astro";
import Header from "../../components/Header.astro";
import BlogCard from "../../components/BlogCard.astro";
import { getCollection } from 'astro:content';
import { getWpBase, getWpPostBySlug, getWpPostById, type NormalizedPost } from "../../utils/wp";

export const prerender = false;

// SSR: resolver el post por slug en cada request para reflejar cambios inmediatos en WordPress
const { slug } = Astro.params;
if (typeof process !== 'undefined' && process.env && process.env.DEBUG_BLOG) {
  console.log('[route:/blog/[slug]] incoming', { slug, url: Astro.url.toString() });
}
const idParam = Astro.url.searchParams.get('id');
let wpPost: NormalizedPost | undefined;
let localPost: any | undefined;
const wpBase = getWpBase();

// NUEVO: si hay idParam, intentamos primero por ID (más determinista)
if (wpBase && idParam && /^\d+$/.test(idParam)) {
  try {
    wpPost = await getWpPostById(Number(idParam));
    if (wpPost && process?.env?.DEBUG_BLOG) {
      console.log('[Blog SSR] Resuelto por ID primero', { requestedId: idParam, resolvedSlug: wpPost.slug });
    }
  } catch (e) {
    console.warn('[Blog SSR] Error al obtener post WP por id (orden primero):', idParam, e);
  }
}

// Si no lo obtuvimos por ID o no había idParam, intentar por slug
if (wpBase && slug && !wpPost) {
  try {
    wpPost = await getWpPostBySlug(slug);
    if (wpPost && process?.env?.DEBUG_BLOG) {
      console.log('[Blog SSR] Resuelto por slug', { slug });
    }
  } catch (e) {
    console.warn('[Blog SSR] Error al obtener post WP por slug:', slug, e);
  }
}

// Si lo obtuvimos por ID pero el slug en la URL no coincide con el slug real del post, redirigir a canónico
if (wpPost && slug && wpPost.slug && slug !== wpPost.slug) {
  const canonical = `/blog/${encodeURIComponent(wpPost.slug)}`; // canonical limpio sin ?id
  if (process?.env?.DEBUG_BLOG) {
    console.log('[Blog SSR] Redirigiendo a slug canónico', { from: slug, to: wpPost.slug, canonical });
  }
  if (Astro.redirect) {
    return Astro.redirect(canonical, 301);
  }
  return new Response('', { status: 301, headers: { Location: canonical } });
}
if (!wpPost && slug) {
  const all = await getCollection('blog');
  localPost = all.find((p) => p.slug === slug);
}
if (!wpPost && !localPost) {
  // User-friendly 404 within site layout
  const title = 'Entrada no encontrada';
  const message = 'No pudimos encontrar esta entrada. Puede que el enlace haya cambiado en WordPress o no esté publicada.';
  return Astro.redirect ? Astro.redirect('/blog', 302) : new Response(
    `<!doctype html><html><head><meta charset="utf-8"><title>${title}</title><meta name="viewport" content="width=device-width, initial-scale=1"/></head><body style="font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif;padding:2rem;max-width:60ch;margin:auto;text-align:center;">
    <h1 style="font-size:1.5rem;margin-bottom:0.5rem;">${title}</h1>
    <p style="color:#475569;">${message}</p>
    <p><a href="/blog" style="color:#0ea5e9;">Volver al blog</a></p>
    </body></html>`,
    { status: 404, headers: { 'content-type': 'text/html; charset=utf-8' } }
  );
}
const isWP = !!wpPost;
// Obtener categorías/tags del post actual (normalizados a strings) para usar en relacionados
function extractCategories(post: any): string[] {
  if (!post) return [];
  // WordPress normalizado: post.data.categories -> [{name}]
  if (post.data && Array.isArray(post.data.categories)) {
    return post.data.categories.map((c: any) => c?.name || c?.title || '').filter(Boolean);
  }
  // Contenido local: usar tags si existen
  if (post.data && Array.isArray(post.data.tags)) return post.data.tags.filter(Boolean);
  return [];
}
const currentCats = isWP ? extractCategories(wpPost) : extractCategories(localPost);

// Buscar relacionados solo si tenemos base WP (para consistencia) o si es local buscar en colección
let related: any[] = [];
try {
  if (isWP) {
    // Descargamos un set razonable y filtramos localmente (evitar múltiples llamadas por categoría)
    const all = await getCollection('blog'); // local fallback collection (puede estar vacía)
    // all quizás no contiene WP; intentar complementar con listWpPosts si hay base
    // Import dinámico para evitar circularidad
    const { listWpPosts } = await import('../../utils/wp');
    const wpPool = await listWpPosts(40); // tamaño razonable
    const pool = [...wpPool];
    related = pool.filter(p => p.slug !== wpPost!.slug && extractCategories(p).some(cat => currentCats.includes(cat))).slice(0,4);
  } else if (localPost) {
    const all = await getCollection('blog');
    related = all.filter(p => p.slug !== localPost.slug && extractCategories(p).some(cat => currentCats.includes(cat))).slice(0,4);
  }
} catch (e) {
  if (import.meta.env.DEV) console.warn('[RelatedPosts] Error obteniendo relacionados', e);
}
let Content: any = null;
if (!isWP && localPost) {
  const rendered = await localPost.render();
  Content = rendered.Content;
}
// Resolver portada: assets locales bajo src/assets/images y retorno de URL string
const assets = import.meta.glob('../../assets/images/**/*', { eager: true, import: 'default' }) as Record<string, any>;
/**
 * @param {string | undefined} path
 * @returns {string | undefined}
 */
function resolveCoverPath(path: string | undefined): string | undefined {
  if (!path) return undefined;
  // /src/... -> clave '../../assets/...'
  if (path.startsWith('/src/')) {
    const key = '../..' + path.replace('/src', '');
    const hit = assets[key];
    if (hit) return typeof hit === 'string' ? hit : hit?.src;
  }
  // ...assets/images/...
  const idx = path.indexOf('assets/images/');
  if (idx !== -1) {
    const tail = path.slice(idx);
    const key = '../..' + '/' + tail.replace(/^assets\//, 'assets/');
    const hit = assets[key];
    if (hit) return typeof hit === 'string' ? hit : hit?.src;
  }
  // Búsqueda por nombre de archivo
  const file = path.split('/').pop();
  if (file) {
    const matchKey = Object.keys(assets).find((k) => k.endsWith('/' + file));
    if (matchKey) {
      const hit = assets[matchKey];
      return typeof hit === 'string' ? hit : hit?.src;
    }
  }
  return undefined;
}
---
<BaseLayout title={`${(isWP ? wpPost!.data.title : localPost.data.title)} | Blog`}>
  <Fragment slot="header"><Header /></Fragment>
  <div class="mx-auto max-w-7xl px-4 lg:px-8">
    <div class="grid grid-cols-1 lg:grid-cols-4 gap-10">
      <article class="prose prose-lg md:prose-xl lg:col-span-3">
    <h1>{isWP ? wpPost!.data.title : localPost.data.title}</h1>
    {isWP ? (
      (() => {
        const cover = wpPost!.data.cover || (() => {
          // fallback: first <img src> inside contentHtml
          const m = wpPost!.contentHtml?.match(/<img[^>]+src=["']([^"']+)["']/i); return m ? m[1] : undefined;
        })();
        const finalCover = cover || '/placeholder-cover.svg';
        // Derivar width/height del patrón -WxH si existe para reducir CLS
        let width: string | undefined; let height: string | undefined;
        const sizeMatch = finalCover.match(/-([0-9]{2,5})x([0-9]{2,5})(\.[a-z]{2,5})(?:$|[?&#])/i);
        if (sizeMatch) { width = sizeMatch[1]; height = sizeMatch[2]; }
        // Construir srcset a partir de candidateCovers (ordenadas de mayor a menor en normalize)
        const candidates: string[] = (wpPost!.data.candidateCovers || []).slice().reverse(); // pequeño->grande para navegador
        // Inferir width del patrón -WxH; si no se detecta, no se añade descriptor
        const entries = candidates.map(u => {
          const m = u.match(/-([0-9]{2,5})x([0-9]{2,5})(\.[a-z]{2,5})(?:$|[?&#])/i);
          if (m) return `${u} ${m[1]}w`;
          return u; // fallback sin descriptor
        });
        const srcset = entries.length ? entries.join(', ') : undefined;
        const sizes = srcset ? '(max-width: 640px) 100vw, (max-width: 1024px) 90vw, 1024px' : undefined;
        const baseProps = {
          id: 'post-cover',
          src: finalCover,
          loading: 'lazy',
          decoding: 'async',
            class: 'w-full aspect-[16/9] object-cover rounded-lg',
          'data-candidates': JSON.stringify(wpPost!.data.candidateCovers || []),
          width,
          height,
          srcset,
          sizes,
        } as any;
        return cover ? (
          <img {...baseProps} alt={wpPost!.data.title} />
        ) : (
          <img {...baseProps} alt="Sin imagen" class={baseProps.class + ' opacity-80'} />
        );
      })()
    ) : (
      (() => {
        const coverPath = localPost.data.cover as string | undefined;
        const resolvedUrl = resolveCoverPath(coverPath);
        if (import.meta.env.DEV && coverPath && (/^(\/.|\.\/|\.\.\/)/.test(coverPath) || coverPath.startsWith('/src/')) && !resolvedUrl) {
          console.warn(`[Blog post] No se pudo resolver la portada local: ${coverPath}. Asegúrate de que exista en src/assets/images y usa una ruta relativa, por ejemplo ../../assets/images/...`);
        }
        const finalSrc = (resolvedUrl || coverPath || '') + '';
        if (!coverPath) return null;
        let width: string | undefined; let height: string | undefined;
        const sizeMatch = finalSrc.match(/-([0-9]{2,5})x([0-9]{2,5})(\.[a-z]{2,5})(?:$|[?&#])/i);
        if (sizeMatch) { width = sizeMatch[1]; height = sizeMatch[2]; }
        return (
          <img
            id="post-cover"
            src={finalSrc}
            alt={localPost.data.title}
            loading="lazy"
            decoding="async"
            width={width}
            height={height}
            class="w-full aspect-[16/9] object-cover rounded-lg"
          />
        );
      })()
    )}
    <p class="text-sm text-slate-500">
      {isWP ? (wpPost!.data.author ? `Por ${wpPost!.data.author}` : new Date(wpPost!.data.date).toLocaleDateString('es')) : new Date(localPost.data.date).toLocaleDateString('es')}
    </p>
    {isWP ? (
      <div class="wp-content" set:html={wpPost!.contentHtml} />
    ) : (
      <div class="wp-content"><Content /></div>
    )}
      </article>
      <aside class="lg:col-span-1 mt-10 lg:mt-0 space-y-4 lg:sticky lg:top-24 self-start">
  <a href="/notas" class="inline-flex items-center gap-2 text-sm font-medium text-sky-600 hover:text-sky-700 border border-sky-200 hover:border-sky-300 rounded-md px-3 py-1.5 transition w-full justify-center">← Ir a Notas</a>
        {related.length > 0 ? (
          <div class="space-y-3">
            <h2 class="text-lg font-semibold">Relacionados</h2>
            <div class="space-y-4 max-h-[calc(100vh-12rem)] overflow-auto pr-1" aria-label="Entradas relacionadas">
              {related.map(r => <BlogCard post={r} />)}
            </div>
          </div>
        ) : (
          <p class="text-sm text-slate-500">No hay entradas relacionadas.</p>
        )}
      </aside>
    </div>
  </div>
  {/* Lightbox modal for post images */}
  <div id="post-lightbox" class="fixed inset-0 z-[9999] hidden" aria-hidden="true">
    <div id="post-backdrop" class="absolute inset-0 bg-black/70"></div>
    <div class="absolute inset-0 flex items-center justify-center p-4">
      <div class="relative w-full max-w-6xl">
        <div class="relative bg-black rounded-lg overflow-hidden">
          <button id="post-closeBtn" class="absolute top-2 right-2 z-10 h-10 w-10 grid place-items-center rounded-full bg-black/50 text-white text-xl hover:bg-black/70" aria-label="Cerrar">×</button>
          <button id="post-prevBtn" class="absolute left-2 top-1/2 -translate-y-1/2 z-10 h-10 w-10 rounded-full bg-black/40 text-white hover:bg-black/60">‹</button>
          <button id="post-nextBtn" class="absolute right-2 top-1/2 -translate-y-1/2 z-10 h-10 w-10 rounded-full bg-black/40 text-white hover:bg-black/60">›</button>
          <div class="w-[min(100vw,96rem)] max-h-[95vh] pt-12 flex items-center justify-center">
            <img id="post-lightboxImage" class="max-h-[95vh] w-auto object-contain select-none" alt="Imagen de entrada" />
          </div>
        </div>
        <div id="post-counter" class="mt-2 text-center text-white/90"></div>
        <div id="post-caption" class="mt-1 text-center text-white/80 text-sm"></div>
      </div>
    </div>
  </div>
  <script>
  // @ts-nocheck
    (function(){
      // Debug: log cover image status and content images load/errors to diagnose missing images
      function debugImages(){
        try {
          const cover = document.getElementById('post-cover');
          if (cover && cover.tagName === 'IMG') {
            const img = /** @type {HTMLImageElement} */ (cover);
            // Fallback rotation over candidate covers if first fails
            const candidatesRaw = img.getAttribute('data-candidates');
            let candidates: string[] = [];
            try { candidates = candidatesRaw ? JSON.parse(candidatesRaw) : []; } catch {}
            const originalSrc = img.getAttribute('src');
            // Remove the already used cover from rotation list
            let rotation = candidates.filter(c => c && c !== originalSrc);
            let attempt = 0; // index into rotation
            console.info('[Blog Debug] Cover element found', {
              src: img.getAttribute('src'),
              currentSrc: img.currentSrc,
              srcset: img.getAttribute('srcset'),
              naturalWidth: img.naturalWidth,
              naturalHeight: img.naturalHeight,
              candidates,
            });
            img.addEventListener('load', () => {
              console.info('[Blog Debug] Cover loaded', {
                currentSrc: img.currentSrc,
                naturalWidth: img.naturalWidth,
                naturalHeight: img.naturalHeight,
              });
            });
            img.addEventListener('error', (e) => {
              console.error('[Blog Debug] Cover failed to load', {
                src: img.getAttribute('src'),
                currentSrc: img.currentSrc,
                error: e,
                attempt,
                rotationLength: rotation.length,
              });
              // Try next alternative size
              if (rotation.length && attempt < rotation.length) {
                const next = rotation[attempt++];
                if (next && next !== img.getAttribute('src')) {
                  console.warn('[Blog Debug] Trying next candidate cover', next);
                  img.src = next;
                  return;
                }
              }
              // If no more alternatives and not yet proxied, try proxy endpoint (may bypass hotlink protection)
              if (!img.dataset.proxyTried) {
                img.dataset.proxyTried = '1';
                const last = img.getAttribute('src') || originalSrc || '';
                if (last.startsWith('/api/img-proxy')) return; // already proxied
                console.warn('[Blog Debug] Attempting proxy for cover', last);
                img.src = '/api/img-proxy?url=' + encodeURIComponent(last);
                return;
              }
              // Final fallback: placeholder
              if (!img.dataset.finalFallback) {
                img.dataset.finalFallback = '1';
                console.warn('[Blog Debug] Falling back to placeholder cover');
                img.src = '/placeholder-cover.svg';
              }
            });
          } else {
            console.info('[Blog Debug] No cover image element present');
          }

          const container = document.querySelector('article .wp-content');
          if (container) {
            const imgs = Array.from(container.querySelectorAll('img'));
            console.info(`[Blog Debug] Encontradas ${imgs.length} imágenes dentro del contenido`);
            imgs.forEach((im, idx) => {
              const i = /** @type {HTMLImageElement} */ (im);
              console.debug('[Blog Debug] Content img initial', idx + 1, {
                src: i.getAttribute('src'),
                currentSrc: i.currentSrc,
                srcset: i.getAttribute('srcset'),
                sizes: i.getAttribute('sizes'),
              });
              i.addEventListener('load', () => {
                console.debug('[Blog Debug] Content img loaded', idx + 1, {
                  currentSrc: i.currentSrc,
                  naturalWidth: i.naturalWidth,
                  naturalHeight: i.naturalHeight,
                });
              });
              i.addEventListener('error', (e) => {
                console.error('[Blog Debug] Content img error', idx + 1, {
                  src: i.getAttribute('src'),
                  currentSrc: i.currentSrc,
                  error: e,
                });
              });
            });
          }

          // Global capture for image resource errors
          window.addEventListener('error', (e) => {
            const t = e && e.target;
            if (t && t.tagName === 'IMG') {
              const img = /** @type {HTMLImageElement} */ (t);
              console.error('[Blog Debug] Global IMG error (captured)', {
                src: img.getAttribute('src'),
                currentSrc: img.currentSrc,
              });
            }
          }, true);
        } catch (err) {
          console.warn('[Blog Debug] Error setting up image debug logs', err);
        }
      }

      function initPostLightbox(){
        const container = document.querySelector('article .wp-content');
        if (!container) return;
        /** @type {HTMLImageElement[]} */
        const imgs = Array.from(container.querySelectorAll('img'))
          .filter(img => img && (img.currentSrc || img.src));
        if (imgs.length === 0) return;

        // Make images look clickable
        imgs.forEach(img => { if (!img.style.cursor) img.style.cursor = 'zoom-in'; });

        // Prepare (src, caption) list
        const items = imgs.map((img) => ({
          src: img.currentSrc || img.src,
          caption: img.getAttribute('alt') || ''
        }));

        const lightbox = document.getElementById('post-lightbox');
        if (!lightbox) return;
        const scope = lightbox;
        const imgEl = scope.querySelector('#post-lightboxImage');
        const closeBtn = scope.querySelector('#post-closeBtn');
        const nextBtn = scope.querySelector('#post-nextBtn');
        const prevBtn = scope.querySelector('#post-prevBtn');
        const backdrop = scope.querySelector('#post-backdrop');
        const counter = scope.querySelector('#post-counter');
        const captionEl = scope.querySelector('#post-caption');

        let current = 0;
        let scale = 1, offsetX = 0, offsetY = 0, isPanning = false, startX = 0, startY = 0;
        function applyTransform(){
          if (!imgEl) return;
          imgEl.style.transform = `translate(${offsetX}px, ${offsetY}px) scale(${scale})`;
          imgEl.style.transition = 'transform 120ms ease-out';
          imgEl.style.cursor = scale > 1 ? 'grab' : 'default';
        }
        function resetZoom(){ scale = 1; offsetX = 0; offsetY = 0; applyTransform(); }
        function update(){
          if (!imgEl) return;
          imgEl.setAttribute('src', items[current].src);
          if (counter) counter.textContent = `${current + 1} / ${items.length}`;
          if (captionEl) captionEl.textContent = items[current].caption || '';
          resetZoom();
        }
        function openAt(idx){ current = idx; update(); scope.classList.remove('hidden'); scope.setAttribute('aria-hidden','false'); scope.style.display='block'; document.body.style.overflow='hidden'; }
        function close(){ scope.classList.add('hidden'); scope.setAttribute('aria-hidden','true'); scope.style.display='none'; document.body.style.overflow=''; }
        function next(){ current = (current + 1) % items.length; update(); }
        function prev(){ current = (current - 1 + items.length) % items.length; update(); }

        // Delegate clicks (also handle anchors wrapping img)
        container.addEventListener('click', (e) => {
          const target = e.target;
          const img = target && target.closest ? target.closest('img') : null;
          if (!img) return;
          const index = imgs.indexOf(img);
          if (index >= 0) {
            e.preventDefault();
            openAt(index);
          }
        });

        if (closeBtn) closeBtn.addEventListener('click', close);
        if (backdrop) backdrop.addEventListener('click', close);
        if (nextBtn) nextBtn.addEventListener('click', next);
        if (prevBtn) prevBtn.addEventListener('click', prev);
        document.addEventListener('keydown', (e) => {
          if (scope.classList.contains('hidden')) return;
          if (e.key === 'Escape') close();
          if (e.key === 'ArrowRight') next();
          if (e.key === 'ArrowLeft') prev();
        });

        if (imgEl) imgEl.addEventListener('dblclick', () => { scale = scale > 1 ? 1 : 2; offsetX = 0; offsetY = 0; applyTransform(); });
        if (imgEl) imgEl.addEventListener('wheel', (e) => { e.preventDefault(); const d = Math.sign(e.deltaY); const prev = scale; scale = Math.min(5, Math.max(1, scale + (d > 0 ? -0.2 : 0.2))); if (scale === 1) { offsetX = 0; offsetY = 0; } if (prev !== scale) applyTransform(); }, { passive: false });
        if (imgEl) imgEl.addEventListener('mousedown', (e) => { if (scale <= 1) return; isPanning = true; startX = e.clientX - offsetX; startY = e.clientY - offsetY; imgEl.style.cursor = 'grabbing'; });
        document.addEventListener('mousemove', (e) => { if (!isPanning) return; offsetX = e.clientX - startX; offsetY = e.clientY - startY; applyTransform(); });
        document.addEventListener('mouseup', () => { isPanning = false; if (imgEl) imgEl.style.cursor = 'grab'; });
      }

      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', () => { debugImages(); initPostLightbox(); });
      } else {
        debugImages();
        initPostLightbox();
      }
      window.addEventListener('beforeunload', () => { document.body.style.overflow = ''; });
    })();
  </script>
</BaseLayout>
